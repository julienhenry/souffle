// Souffle - A Datalog Compiler
// Copyright (c) 2021, The Souffle Developers. All rights reserved
// Licensed under the Universal Permissive License v 1.0 as shown at:
// - https://opensource.org/licenses/UPL
// - <souffle root>/licenses/SOUFFLE-UPL.txt


.type I = [lb:number, ub:number]
.functor lub(a:I, b:I):I stateful
.functor glb(a:I, b:I):I stateful

.init ex1 = _ex1
.init ex2 = _ex2
.init ex3 = _ex3
.init ex4 = _ex4
.init ex5 = _ex5
.init ex6 = _ex6

.comp _ex1 {
    // Simple Interval Analysis for analyzing value ranges of program variables
    .type Interval = I

    .type Node <: symbol
    .type Variable <: symbol

    .decl Edge(n:Node,succ: Node)
    .decl Set_Value(n:Node,v:Variable, value:number)
    .decl Increment_Value(n:Node,v:Variable,inc:number)
    .decl Restrict_Value_Lb(n:Node, v:Variable, lb:number)
    .decl Restrict_Value_Ub(n:Node, v:Variable, ub:number)

    /* Encoding the program:
    v = 0;
    while(v <= 100) {
        v = v + 2;
    }
    */
    Edge("start","start_to_head").
    Edge("start_to_head", "head").
    Edge("head","cond").
    Edge("cond","incr").
    Edge("incr","incr_to_head").
    Edge("incr_to_head","head").
    Edge("head","not cond").
    Edge("not cond","end").

    Set_Value("start","v", 0).
    Restrict_Value_Ub("cond","v", 100).
    Restrict_Value_Lb("not cond","v", 101).
    Increment_Value("incr", "v", 2).

    .lattice Interval<> {
        Lub    -> @lub(_,_)
    }

    // Possible values for v after statement n, expressed with an interval
    // for instance: Values("head", "v", [0, 50])
    .decl Values(
        n:Node,
        v:Variable,
        i:Interval<>)

    .output Values

    Values(n, v, [x, x]) :-
        Set_Value(n, v, x).

    Values(n, v, i) :-
        Values(pred, v, i),
        Edge(pred, n),
        !Set_Value(n, v, _),
        !Increment_Value(n, v, _),
        !Restrict_Value_Lb(n, v, _),
        !Restrict_Value_Ub(n, v, _).

    Values(n, v, [lb+x, ub+x]) :-
        Values(pred, v, [lb, ub]),
        Edge(pred, n),
        Increment_Value(n, v, x).

    Values(n, v, [max_lb, ub]) :-
        Values(pred, v, [lb, ub]),
        Edge(pred, n),
        Restrict_Value_Lb(n, v, x),
        max_lb = max(x, lb),
        max_lb <= ub.

    Values(n, v, [lb, min_ub]) :-
        Values(pred, v, [lb, ub]),
        Edge(pred, n),
        Restrict_Value_Ub(n, v, x),
        min_ub = min(x, ub),
        min_ub >= lb.
}

.comp _ex2 {
    // testing lub on a non-recursive relation Y

    .type Interval = I

    .lattice Interval<> {
        Lub    -> @lub(_,_)
    }

    .decl X(x:number)

    .decl R(
        x:number,
        i:Interval<>,
        j:Interval<>)
    .output R()

    X(42).

    R(x, [20, 30], [1, 2]),
    R(x, [0, 10], [6,10]) :-
        X(x).
}

.comp _ex3 {
    // testing lub on a recursive relation Y with non-recursive clauses

    .type Interval = I

    .lattice Interval<> {
        Lub    -> @lub(_,_)
    }

    .decl X(x:number)

    .decl R(
        x:number,
        i:Interval<>,
        j:Interval<>)
    .output R()

    X(42).

    R(x, [20, 30], [1, 2]),
    R(x, [0, 10], [6,10]) :-
        X(x).

    // after non-recursive clause, we should have
    // R(42, [0, 30], [1, 10])
    // so this should iterate until
    // R(42, [0, 50], [1, 30])
    R(x, [a, b+1], [c, d+1]) :-
        R(x, [a,b], [c, d]),
        b < 50,
        d < 50.

}

.comp _ex4 {
    // testing glb

    .type Interval = I

    .lattice Interval<> {
        Bottom -> [0, -1],
        Lub    -> @lub(_,_),
        Glb    -> @glb(_,_)
    }

    .decl X(x:number, i:Interval<>)
    .decl Y(x:number, i:Interval<>)
    .decl R(x:number, i:Interval<>)
    .output R()

    X(0, [0,100]).
    Y(0, [50, 150]).

    R(x, i) :-
        X(x, i),
        Y(x, i).

}

.comp _ex5 {
    // testing glb

    .type Interval = I

    .lattice Interval<> {
        Bottom -> [0, -1],
        Lub    -> @lub(_,_),
        Glb    -> @glb(_,_)
    }

    .decl X(i:Interval<>)
    .decl Y(i:Interval)
    .decl R(i:Interval<>)
    .output R()

    X([0,100]).
    Y([50, 150]).

    R(i) :-
        X(i),
        Y(i).

    .decl A(i:Interval<>)
    .decl B(i:Interval<>)
    .decl C(i:Interval<>)
    .output C()

    A([-10, -1]).
    B([1, 100]).
    C(i) :- A(i), B(i).

}


.functor sign_lub(a:S, b:S):S stateful
.functor sign_glb(a:S, b:S):S stateful

.type S =
    Bottom{}
  | Negative{}
  | Positive{}
  | Top{}
  | Zero{}

.comp _ex6 {

    .type Sign = S

    .lattice Sign<> {
        Bottom -> $Bottom(),
        Top -> $Top(),
        Lub -> @sign_lub(_,_),
        Glb -> @sign_glb(_,_)
    }

    .decl N(n:number)

    N(x) :- x = range(-10, 10).

    .decl S(n:number, s:Sign<>)

    S(n, s) :-
        N(n),
        (
            n = 0, s = $Zero();
            n > 0, s = $Positive();
            n < 0, s = $Negative()
        ).

    .decl R(n:symbol, s:Sign<>)
    .output R()

    R("pos", s) :-
        S(x, s), x > 0.

    R("neg", s) :-
        S(x, s), x < 0.

    R("top", s) :-
        S(_, s).

    .decl R2(n:symbol)
    .output R2()

    R2(x) :-
        R(x, $Top()).
}